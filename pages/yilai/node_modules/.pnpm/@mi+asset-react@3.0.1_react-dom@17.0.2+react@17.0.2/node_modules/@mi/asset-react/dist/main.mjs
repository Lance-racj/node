var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/AssetImage.tsx
import React2, { useRef as useRef2, useState as useState2 } from "react";

// src/use-resize-observer.ts
import { useEffect } from "react";
import ResizeObserver from "resize-observer-polyfill";
var observer = null;
function useResizeObserver(elementRef, callback) {
  useEffect(() => {
    if (!observer) {
      observer = new ResizeObserver((entries, observer3) => {
        entries.forEach((entry) => {
          var _a, _b;
          (_b = (_a = entry.target)._resizeHandler) == null ? void 0 : _b.call(_a, entry, observer3);
        });
      });
    }
    if (observer && elementRef.current) {
      elementRef.current._resizeHandler = callback;
      observer.observe(elementRef.current);
    }
    return () => {
      if (observer && elementRef.current) {
        observer.unobserve(elementRef.current);
      }
    };
  }, []);
}

// ../shared/lib/calc.ts
function getAspectRatio(width, height) {
  if (!height || !width) {
    throw new Error("You must provide height and width.");
  }
  const aspectRatio = height / width;
  if (isNaN(aspectRatio)) {
    throw new Error("Invalid width or height");
  }
  return aspectRatio;
}
function getObjectFitWidth(containerWidth, containerHeight, imageWidth, imageHeight, objectFit) {
  const naturalRatio = imageWidth / imageHeight;
  const visibleRatio = containerWidth / containerHeight;
  if (objectFit === "none") {
    return imageWidth;
  }
  if (objectFit === "contain" || objectFit === "scale-down") {
    const objectFitWidth = naturalRatio > visibleRatio ? containerWidth : containerHeight / imageHeight * imageWidth;
    return objectFit === "contain" ? objectFitWidth : Math.min(imageWidth / objectFitWidth);
  }
  if (objectFit === "cover") {
    return naturalRatio > visibleRatio ? containerHeight * naturalRatio : containerWidth;
  }
  return containerWidth;
}

// ../shared/lib/const.ts
var PLACEHOLDER_BLURRED = 5;
var TRANSITION_TIME_FUNCTION = "cubic-bezier(0.25, 0.46, 0.45, 0.94)";
var TRANSITION_DURATION = 330;

// ../shared/lib/style.ts
var insetStyle = {
  top: 0,
  height: "100%",
  left: 0,
  width: "100%"
};
function generateContainerStyle(layout, width, height, backgroundColor, userStyle) {
  return __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    position: "relative",
    overflow: "hidden"
  }, layout === "fill" && __spreadValues({
    position: "absolute"
  }, insetStyle)), layout === "intrinsic" && {
    maxWidth: width + "px"
  }), layout === "responsive" && {}), layout === "fixed" && {
    width: width + "px",
    height: height + "px"
  }), {
    backgroundColor
  }), userStyle);
}
function generatePlaceholderStyle(objectFit, objectPosition, userStyle) {
  return __spreadValues(__spreadValues({
    display: "block",
    position: "absolute",
    filter: `blur(${PLACEHOLDER_BLURRED}px)`,
    transform: `scale(1.1)`,
    objectFit,
    objectPosition
  }, insetStyle), userStyle);
}
function generateImageStyle(objectFit, objectPosition, userStyle) {
  return __spreadValues(__spreadProps(__spreadValues({
    display: "block",
    position: "absolute"
  }, insetStyle), {
    objectFit,
    objectPosition
  }), userStyle);
}

// ../shared/lib/utils.ts
function generateImageUrl(path, options = {}) {
  const {
    width = 0,
    quality = 0,
    format = "",
    secret = "",
    base = ""
  } = options;
  const PUBLIC_BASE_URL = "https://cdna.sec.miui.com";
  const PRIVATE_BASE_URL = "https://a.sec.miui.com";
  const url = new URL(path, base || (secret ? PRIVATE_BASE_URL : PUBLIC_BASE_URL));
  const searchParams = new URLSearchParams();
  if (width) {
    searchParams.append("width", width.toFixed(0));
  }
  if (format) {
    searchParams.append("format", format);
  }
  if (quality) {
    searchParams.append("quality", quality.toFixed(0));
  }
  if (secret) {
    searchParams.append("secret", secret);
  }
  const query = searchParams.toString();
  return url + "?" + query;
}
var SUPPORT_WEBP = null;
function getWebpSupport() {
  if (SUPPORT_WEBP === null) {
    const canvas = document.createElement("canvas");
    if (!!(canvas.getContext && canvas.getContext("2d"))) {
      SUPPORT_WEBP = canvas.toDataURL("image/webp").indexOf("data:image/webp") == 0;
    } else {
      SUPPORT_WEBP = false;
    }
  }
  return SUPPORT_WEBP;
}
function merge(...obj) {
  const result = {};
  obj.forEach((item) => {
    Object.entries(item).forEach(([key, value]) => {
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}

// src/use-intersection-observer.ts
import { useEffect as useEffect2 } from "react";
var observer2 = null;
function useIntersectionObserver(elementRef, callback) {
  useEffect2(() => {
    if (!observer2 && window.IntersectionObserver) {
      observer2 = new IntersectionObserver((entries, observer3) => {
        entries.forEach((entry) => {
          var _a;
          const target = entry.target;
          (_a = target == null ? void 0 : target._intersectionHandler) == null ? void 0 : _a.call(target, entry, observer3);
        });
      }, {
        rootMargin: "10%"
      });
    }
    if (observer2 && elementRef.current) {
      elementRef.current._intersectionHandler = callback;
      observer2.observe(elementRef.current);
    }
    return () => {
      if (observer2 && elementRef.current) {
        observer2.unobserve(elementRef.current);
      }
    };
  }, []);
}

// src/use-props.ts
import { useContext } from "react";

// src/ConfigProvider.tsx
import React from "react";
var ConfigContext = React.createContext({});
var ConfigProvider = (_a) => {
  var _b = _a, {
    children
  } = _b, config = __objRest(_b, [
    "children"
  ]);
  return /* @__PURE__ */ React.createElement(ConfigContext.Provider, {
    value: config
  }, children);
};

// src/use-props.ts
var defaultConfig = {
  quality: 80,
  sizeStep: 100,
  objectPosition: "center",
  objectFit: "cover",
  animation: true,
  lazy: true
};
function useProps(componentProps) {
  const globalConfig = useContext(ConfigContext);
  return merge(defaultConfig, globalConfig, componentProps || {});
}

// src/use-image-url-generator.ts
import { useEffect as useEffect3, useState } from "react";
function useImageUrlGenerator() {
  const props = useProps();
  const [generator, setGenerator] = useState(null);
  useEffect3(() => {
    const isSupportWebp = getWebpSupport();
    setGenerator(() => {
      return (path, options = {}) => {
        const {
          quality = props.quality,
          format = path.split(".").pop() !== "svg" && isSupportWebp ? "webp" : void 0,
          secret = props.secretToken,
          base = props.baseUrl,
          width = 0
        } = options;
        return generateImageUrl(path, {
          width,
          quality,
          format,
          secret,
          base
        });
      };
    });
  }, []);
  return generator;
}

// src/use-debounce-func.tsx
import { useCallback, useEffect as useEffect4, useRef } from "react";
function useDebounceFunction(func, wait, immediate = false) {
  const timerRef = useRef(null);
  const immediateRef = useRef(immediate);
  const callback = useCallback((...args) => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    if (wait <= 0) {
      func.apply(void 0, args);
    }
    if (immediateRef.current) {
      func.apply(void 0, args);
      immediateRef.current = false;
    }
    timerRef.current = setTimeout(() => func.apply(void 0, args), wait);
  }, [wait, immediate]);
  useEffect4(() => {
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, []);
  return callback;
}

// src/AssetImage.tsx
var AssetImage = (componentProps) => {
  const props = useProps(componentProps);
  const generateImageUrl2 = useImageUrlGenerator();
  const containerRef = useRef2(null);
  const [shouldLoadImage, setShouldLoadImage] = useState2(!props.lazy);
  const [showImage, setShowImage] = useState2(false);
  const [computedWidth, setComputedWidth] = useState2(0);
  const setComputedWidthDebounce = useDebounceFunction(setComputedWidth, 300, true);
  const [shouldLoadPlaceholder, setShouldLoadPlaceholder] = useState2(!!props.placeholder);
  const setShouldLoadPlaceholderDebounce = useDebounceFunction(setShouldLoadPlaceholder, TRANSITION_DURATION);
  const isNeedPlaceholderElement = props.layout === "fixed" || props.layout === "intrinsic" || props.layout === "responsive";
  const onImageLoad = () => {
    setShowImage(true);
    if (shouldLoadPlaceholder) {
      setShouldLoadPlaceholderDebounce(false);
    }
  };
  useIntersectionObserver(containerRef, (entry, observer3) => {
    if (entry.isIntersecting) {
      setShouldLoadImage(true);
      observer3.unobserve(entry.target);
    }
  });
  useResizeObserver(containerRef, (entry) => {
    const { width, height, sizeStep, layout, objectFit } = props;
    const rectWidth = entry.contentRect.width;
    const rectHeight = entry.contentRect.height;
    const imageWidth = layout === "fill" ? getObjectFitWidth(rectWidth, rectHeight, width, height, objectFit) : rectWidth;
    if (rectWidth && sizeStep && sizeStep > 0) {
      const newWidth = Math.min(width, Math.ceil((imageWidth * window.devicePixelRatio || 1) / sizeStep) * sizeStep);
      if (newWidth !== computedWidth) {
        setComputedWidthDebounce(newWidth);
      }
    }
  });
  const containerStyle = generateContainerStyle(props.layout, props.width, props.height, props.backgroundColor, props.style);
  const placeholderImageStyle = generatePlaceholderStyle(props.objectFit, props.objectPosition, {
    opacity: showImage ? 0 : 1,
    transition: props.animation ? `opacity ${TRANSITION_DURATION}ms ${TRANSITION_TIME_FUNCTION}` : ""
  });
  const imageStyle = generateImageStyle(props.objectFit, props.objectPosition, __spreadValues(__spreadValues({}, props.imageStyle), !props.placeholder && props.animation && {
    opacity: showImage ? 1 : 0,
    transition: `opacity ${TRANSITION_DURATION}ms ${TRANSITION_TIME_FUNCTION}`
  }));
  return /* @__PURE__ */ React2.createElement("div", {
    style: containerStyle,
    className: props.className,
    ref: containerRef
  }, isNeedPlaceholderElement && /* @__PURE__ */ React2.createElement("div", {
    style: {
      paddingTop: getAspectRatio(props.width, props.height) * 100 + "%"
    }
  }), shouldLoadImage && computedWidth && generateImageUrl2 && /* @__PURE__ */ React2.createElement("img", {
    style: imageStyle,
    className: props.imageClassName,
    alt: props.alt,
    src: generateImageUrl2(props.path, {
      width: computedWidth
    }),
    onLoad: onImageLoad,
    decoding: "async"
  }), shouldLoadPlaceholder && /* @__PURE__ */ React2.createElement("img", {
    src: props.placeholder,
    style: placeholderImageStyle
  }));
};
export {
  AssetImage,
  ConfigContext,
  ConfigProvider,
  useImageUrlGenerator
};
//# sourceMappingURL=main.mjs