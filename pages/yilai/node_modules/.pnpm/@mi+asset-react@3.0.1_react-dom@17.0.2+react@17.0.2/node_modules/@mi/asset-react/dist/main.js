var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/main.ts
__export(exports, {
  AssetImage: () => AssetImage,
  ConfigContext: () => ConfigContext,
  ConfigProvider: () => ConfigProvider,
  useImageUrlGenerator: () => useImageUrlGenerator
});

// src/AssetImage.tsx
var import_react7 = __toModule(require("react"));

// src/use-resize-observer.ts
var import_react = __toModule(require("react"));
var import_resize_observer_polyfill = __toModule(require("resize-observer-polyfill"));
var observer = null;
function useResizeObserver(elementRef, callback) {
  (0, import_react.useEffect)(() => {
    if (!observer) {
      observer = new import_resize_observer_polyfill.default((entries, observer3) => {
        entries.forEach((entry) => {
          var _a, _b;
          (_b = (_a = entry.target)._resizeHandler) == null ? void 0 : _b.call(_a, entry, observer3);
        });
      });
    }
    if (observer && elementRef.current) {
      elementRef.current._resizeHandler = callback;
      observer.observe(elementRef.current);
    }
    return () => {
      if (observer && elementRef.current) {
        observer.unobserve(elementRef.current);
      }
    };
  }, []);
}

// ../shared/lib/calc.ts
function getWindowAspectRatio() {
  return Math.min(3, window.devicePixelRatio || 1);
}
function getAspectRatio(width, height) {
  if (!height || !width) {
    throw new Error("You must provide height and width.");
  }
  const aspectRatio = height / width;
  if (isNaN(aspectRatio)) {
    throw new Error("Invalid width or height");
  }
  return aspectRatio;
}
function getObjectFitWidth(containerWidth, containerHeight, imageWidth, imageHeight, objectFit) {
  const naturalRatio = imageWidth / imageHeight;
  const visibleRatio = containerWidth / containerHeight;
  if (objectFit === "none") {
    return imageWidth;
  }
  if (objectFit === "contain" || objectFit === "scale-down") {
    const objectFitWidth = naturalRatio > visibleRatio ? containerWidth : containerHeight / imageHeight * imageWidth;
    return objectFit === "contain" ? objectFitWidth : Math.min(imageWidth / objectFitWidth);
  }
  if (objectFit === "cover") {
    return naturalRatio > visibleRatio ? containerHeight * naturalRatio : containerWidth;
  }
  return containerWidth;
}

// ../shared/lib/const.ts
var PLACEHOLDER_BLURRED = 5;
var TRANSITION_TIME_FUNCTION = "cubic-bezier(0.25, 0.46, 0.45, 0.94)";
var TRANSITION_DURATION = 330;

// ../shared/lib/style.ts
var insetStyle = {
  top: 0,
  height: "100%",
  left: 0,
  width: "100%"
};
function generateContainerStyle(layout, width, height, backgroundColor, userStyle) {
  return __spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    position: "relative",
    overflow: "hidden"
  }, layout === "fill" && __spreadValues({
    position: "absolute"
  }, insetStyle)), layout === "intrinsic" && {
    maxWidth: width + "px"
  }), layout === "responsive" && {}), layout === "fixed" && {
    width: width + "px",
    height: height + "px"
  }), {
    backgroundColor
  }), userStyle);
}
function generatePlaceholderStyle(objectFit, objectPosition, userStyle) {
  return __spreadValues(__spreadValues({
    display: "block",
    position: "absolute",
    filter: `blur(${PLACEHOLDER_BLURRED}px)`,
    transform: `scale(1.1)`,
    objectFit,
    objectPosition
  }, insetStyle), userStyle);
}
function generateImageStyle(objectFit, objectPosition, userStyle) {
  return __spreadValues(__spreadProps(__spreadValues({
    display: "block",
    position: "absolute"
  }, insetStyle), {
    objectFit,
    objectPosition
  }), userStyle);
}

// ../shared/lib/utils.ts
var PUBLIC_BASE_URL_CI = "https://cia.sec.miui.com";
var PUBLIC_BASE_URL = "https://cdna.sec.miui.com";
var PRIVATE_BASE_URL = "https://a.sec.miui.com";
function genQueryString(options) {
  const searchParams = new URLSearchParams();
  const { width = 0, quality = 0, format = "" } = options;
  if (width) {
    searchParams.append("width", width.toFixed(0));
  }
  if (format) {
    searchParams.append("format", format);
  }
  if (quality) {
    searchParams.append("quality", quality.toFixed(0));
  }
  return searchParams.toString();
}
function genQueryStringCI(options) {
  let query = "";
  const { width = 0, quality = 0, format = "" } = options;
  if (width) {
    query += `/thumbnail/${width}x`;
  }
  if (quality) {
    query += `/quality/${quality}`;
  }
  if (format) {
    query += `/format/${format}`;
  }
  if (query) {
    query = `imageMogr2` + query;
  }
  return query;
}
function generateImageUrl(path, options = {}) {
  const isSvg = path.split(".").pop() === "svg";
  let base = options.base;
  let query = "";
  if (!base) {
    base = options.secret ? PRIVATE_BASE_URL : PUBLIC_BASE_URL_CI;
  }
  if (options.secret) {
    query = `secret=${options.secret}`;
  }
  const url = new URL(path, base);
  if (isSvg) {
  } else if (base === PRIVATE_BASE_URL || base === PUBLIC_BASE_URL) {
    query = resolveQueryString(query, genQueryString(options));
  } else if (base === PUBLIC_BASE_URL_CI) {
    query = resolveQueryString(query, genQueryStringCI(options));
  }
  return url.toString() + (query ? "?" + query : "");
}
var SUPPORT_WEBP = null;
function getWebpSupport() {
  if (SUPPORT_WEBP === null) {
    const canvas = document.createElement("canvas");
    if (!!(canvas.getContext && canvas.getContext("2d"))) {
      SUPPORT_WEBP = canvas.toDataURL("image/webp").indexOf("data:image/webp") == 0;
    } else {
      SUPPORT_WEBP = false;
    }
  }
  return SUPPORT_WEBP;
}
function merge(...obj) {
  const result = {};
  obj.forEach((item) => {
    Object.entries(item).forEach(([key, value]) => {
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}
function resolveQueryString(...params) {
  let base = params[0];
  for (let i = 1; i < params.length; i++) {
    const cur = params[i];
    if (cur) {
      base = (base ? `${base}&` : "") + params[i];
    }
  }
  return base;
}

// src/use-intersection-observer.ts
var import_react2 = __toModule(require("react"));
var observer2 = null;
function useIntersectionObserver(elementRef, callback) {
  (0, import_react2.useEffect)(() => {
    if (!observer2 && window.IntersectionObserver) {
      observer2 = new IntersectionObserver((entries, observer3) => {
        entries.forEach((entry) => {
          var _a;
          const target = entry.target;
          (_a = target == null ? void 0 : target._intersectionHandler) == null ? void 0 : _a.call(target, entry, observer3);
        });
      }, {
        rootMargin: "10%"
      });
    }
    if (observer2 && elementRef.current) {
      elementRef.current._intersectionHandler = callback;
      observer2.observe(elementRef.current);
    }
    return () => {
      if (observer2 && elementRef.current) {
        observer2.unobserve(elementRef.current);
      }
    };
  }, []);
}

// src/use-props.ts
var import_react4 = __toModule(require("react"));

// src/ConfigProvider.tsx
var import_react3 = __toModule(require("react"));
var ConfigContext = import_react3.default.createContext({});
var ConfigProvider = (_a) => {
  var _b = _a, {
    children
  } = _b, config = __objRest(_b, [
    "children"
  ]);
  return /* @__PURE__ */ import_react3.default.createElement(ConfigContext.Provider, {
    value: config
  }, children);
};

// src/use-props.ts
var defaultConfig = {
  quality: 80,
  sizeStep: 100,
  objectPosition: "center",
  objectFit: "cover",
  animation: true,
  lazy: true
};
function useProps(componentProps) {
  const globalConfig = (0, import_react4.useContext)(ConfigContext);
  return merge(defaultConfig, globalConfig, componentProps || {});
}

// src/use-image-url-generator.ts
var import_react5 = __toModule(require("react"));
function useImageUrlGenerator() {
  const props = useProps();
  const [generator, setGenerator] = (0, import_react5.useState)(null);
  (0, import_react5.useEffect)(() => {
    const isSupportWebp = getWebpSupport();
    setGenerator(() => {
      return (path, options = {}) => {
        const {
          quality = props.quality,
          format = isSupportWebp ? "webp" : void 0,
          secret = props.secretToken,
          base = props.baseUrl,
          width = 0
        } = options;
        return generateImageUrl(path, {
          width,
          quality,
          format,
          secret,
          base
        });
      };
    });
  }, []);
  return generator;
}

// src/use-debounce-func.tsx
var import_react6 = __toModule(require("react"));
function useDebounceFunction(func, wait, immediate = false) {
  const timerRef = (0, import_react6.useRef)(null);
  const immediateRef = (0, import_react6.useRef)(immediate);
  const callback = (0, import_react6.useCallback)((...args) => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
    if (wait <= 0) {
      func.apply(void 0, args);
    }
    if (immediateRef.current) {
      func.apply(void 0, args);
      immediateRef.current = false;
    }
    timerRef.current = setTimeout(() => func.apply(void 0, args), wait);
  }, [wait, immediate]);
  (0, import_react6.useEffect)(() => {
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
      }
    };
  }, []);
  return callback;
}

// src/AssetImage.tsx
var AssetImage = (componentProps) => {
  const props = useProps(componentProps);
  const generateImageUrl2 = useImageUrlGenerator();
  const containerRef = (0, import_react7.useRef)(null);
  const [shouldLoadImage, setShouldLoadImage] = (0, import_react7.useState)(!props.lazy);
  const [showImage, setShowImage] = (0, import_react7.useState)(false);
  const [computedWidth, setComputedWidth] = (0, import_react7.useState)(0);
  const setComputedWidthDebounce = useDebounceFunction(setComputedWidth, 300, true);
  const [shouldLoadPlaceholder, setShouldLoadPlaceholder] = (0, import_react7.useState)(!!props.placeholder);
  const setShouldLoadPlaceholderDebounce = useDebounceFunction(setShouldLoadPlaceholder, TRANSITION_DURATION);
  const isNeedPlaceholderElement = props.layout === "fixed" || props.layout === "intrinsic" || props.layout === "responsive";
  const onImageLoad = () => {
    setShowImage(true);
    if (shouldLoadPlaceholder) {
      setShouldLoadPlaceholderDebounce(false);
    }
  };
  useIntersectionObserver(containerRef, (entry, observer3) => {
    if (entry.isIntersecting) {
      setShouldLoadImage(true);
      observer3.unobserve(entry.target);
    }
  });
  useResizeObserver(containerRef, (entry) => {
    const { width, height, sizeStep, layout, objectFit } = props;
    const rectWidth = entry.contentRect.width;
    const rectHeight = entry.contentRect.height;
    const imageWidth = layout === "fill" ? getObjectFitWidth(rectWidth, rectHeight, width, height, objectFit) : rectWidth;
    if (rectWidth && sizeStep && sizeStep > 0) {
      const newWidth = Math.min(width, Math.ceil(imageWidth * getWindowAspectRatio() / sizeStep) * sizeStep);
      if (newWidth !== computedWidth) {
        setComputedWidthDebounce(newWidth);
      }
    }
  });
  const containerStyle = generateContainerStyle(props.layout, props.width, props.height, props.backgroundColor, props.style);
  const placeholderImageStyle = generatePlaceholderStyle(props.objectFit, props.objectPosition, {
    opacity: showImage ? 0 : 1,
    transition: props.animation ? `opacity ${TRANSITION_DURATION}ms ${TRANSITION_TIME_FUNCTION}` : ""
  });
  const imageStyle = generateImageStyle(props.objectFit, props.objectPosition, __spreadValues(__spreadValues({}, props.imageStyle), !props.placeholder && props.animation && {
    opacity: showImage ? 1 : 0,
    transition: `opacity ${TRANSITION_DURATION}ms ${TRANSITION_TIME_FUNCTION}`
  }));
  return /* @__PURE__ */ import_react7.default.createElement("div", {
    style: containerStyle,
    className: props.className,
    ref: containerRef
  }, isNeedPlaceholderElement && /* @__PURE__ */ import_react7.default.createElement("div", {
    style: {
      paddingTop: getAspectRatio(props.width, props.height) * 100 + "%"
    }
  }), shouldLoadImage && computedWidth && generateImageUrl2 && /* @__PURE__ */ import_react7.default.createElement("img", {
    style: imageStyle,
    className: props.imageClassName,
    alt: props.alt,
    src: generateImageUrl2(props.path, {
      width: computedWidth,
      quality: props.quality,
      format: props.format,
      secret: props.secretToken
    }),
    onLoad: onImageLoad,
    decoding: "async"
  }), shouldLoadPlaceholder && /* @__PURE__ */ import_react7.default.createElement("img", {
    src: props.placeholder,
    style: placeholderImageStyle
  }));
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AssetImage,
  ConfigContext,
  ConfigProvider,
  useImageUrlGenerator
});
//# sourceMappingURL=main.js