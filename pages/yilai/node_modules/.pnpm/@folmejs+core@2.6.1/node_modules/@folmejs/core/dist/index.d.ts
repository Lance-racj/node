import { Properties } from 'csstype';

declare type FolmeEventBus = Array<(() => void) | null>;
declare global {
    interface Window {
        FOLME_EVENT_BUS?: FolmeEventBus;
    }
}
/**
 * Push an event into global event bus. It will trigger the event handler,
 * all of the events in the same frame will be executed together.
 * @param event Event
 */
declare function pushToEventBus(event: () => void): void;
/**
 * Delete the event from global event bus.
 * @param event Event
 */
declare function deleteFromEventBus(event: () => void): void;

declare type FolmeTimer = ReturnType<typeof createTimer>;
declare type FolmeTimerCallbackFunction = (dt: number) => void;
/** Create a new timer.
 * You can create multiple timers and don't worry about the performance,
 * all the timers share one requestAnimationFrame.
 */
declare function createTimer(): {
    start: () => void;
    stop: () => void;
    listen: (fn: FolmeTimerCallbackFunction) => void;
};

declare type FolmeDomEventQueue = Array<() => void>;
/**
 * Adds a job to the read batch and
 * schedules a new microtask if need be.
 */
declare function measureDom(fn: () => void): void;
/**
 * Adds a job to the write batch and
 * schedules a new microtask if need be.
 */
declare function mutateDom(fn: () => void): void;

/**
 * Call function after delay time.
 * @param event Event function
 * @param delay Delay time, unit: (s)
 * @param identity Identifier of event, use for delete from the queue.
 */
declare function pushToDelayQueue<T>(event: () => void, delay: number, identity?: T): void;
/**
 * Delete all the event from the queue which have same identity.
 * @param identity Identifier of event
 */
declare function deleteFromDelayQueue<T>(fn: (identity: T) => boolean): void;
declare function getDelayEvents<T>(fn: (identity: T) => boolean): any[];

/**
 * Define a spring easing function.
 * @param damping - Default *0.9*
 * @param response - Default *0.3*
 * Require `target`, `value`, `velocity`, `deltaTime`
 */
declare function spring(damping?: number, response?: number): FolmeEasingFunction;

/**
 * Define a friction easing function
 * @param rate Deceleration Rate. 0 < rate < 1.
 *
 * Require `startVelocity`, `time`, `startValue`
 */
declare function friction(rate?: number): FolmeEasingFunction;
declare function getFrictionFinalValue(startValue: number, startVelocity: number, rate?: number): number;
declare function getFrictionRate(final: number, startValue: number, startVelocity: number): number;

declare function defineTweenFunction(duration: number, func: (t: number) => number): FolmeEasingFunction;
declare function linear(duration?: number): FolmeEasingFunction;
declare function backIn(duration?: number): FolmeEasingFunction;
declare function backOut(duration?: number): FolmeEasingFunction;
declare function backInOut(duration?: number): FolmeEasingFunction;
declare function bounceIn(duration?: number): FolmeEasingFunction;
declare function bounceOut(duration?: number): FolmeEasingFunction;
declare function bounceInOut(duration?: number): FolmeEasingFunction;
declare function circIn(duration?: number): FolmeEasingFunction;
declare function circOut(duration?: number): FolmeEasingFunction;
declare function circInOut(duration?: number): FolmeEasingFunction;
declare function cubicIn(duration?: number): FolmeEasingFunction;
declare function cubicOut(duration?: number): FolmeEasingFunction;
declare function cubicInOut(duration?: number): FolmeEasingFunction;
declare function elasticIn(duration?: number): FolmeEasingFunction;
declare function elasticOut(duration?: number): FolmeEasingFunction;
declare function elasticInOut(duration?: number): FolmeEasingFunction;
declare function expoIn(duration?: number): FolmeEasingFunction;
declare function expoOut(duration?: number): FolmeEasingFunction;
declare function expoInOut(duration?: number): FolmeEasingFunction;
declare function quadIn(duration?: number): FolmeEasingFunction;
declare function quadOut(duration?: number): FolmeEasingFunction;
declare function quadInOut(duration?: number): FolmeEasingFunction;
declare function quartIn(duration?: number): FolmeEasingFunction;
declare function quartOut(duration?: number): FolmeEasingFunction;
declare function quartInOut(duration?: number): FolmeEasingFunction;
declare function quintIn(duration?: number): FolmeEasingFunction;
declare function quintOut(duration?: number): FolmeEasingFunction;
declare function quintInOut(duration?: number): FolmeEasingFunction;
declare function sinIn(duration?: number): FolmeEasingFunction;
declare function sinOut(duration?: number): FolmeEasingFunction;
declare function sinInOut(duration?: number): FolmeEasingFunction;
declare function springNative(duration?: number, damping?: number, response?: number): FolmeEasingFunction;
/**
 * An interpolator where the rate of change starts out quickly and
 * and then decelerates.
 */
declare function decNative(duration?: number, factor?: number): FolmeEasingFunction;
/**
 * An interpolator where the rate of change starts out slowly and
 * and then accelerates.
 */
declare function accNative(duration?: number, factor?: number): FolmeEasingFunction;
/**
 * An interpolator where the rate of change starts and ends slowly but
 * accelerates through the middle.
 */
declare function accDecNative(duration?: number): FolmeEasingFunction;
/**
 * An interpolator where the change bounces at the end.
 */
declare function bounceNative(duration?: number): FolmeEasingFunction;

interface FolmeEasingFunctionParams {
    /** Target value */
    target?: number;
    /** Current value */
    value?: number;
    /** Current velocity */
    velocity?: number;
    /** Start Velocity */
    startVelocity?: number;
    /** Start Value */
    startValue?: number;
    /** Time interval, unit: seconds */
    deltaTime?: number;
    /** Time from start  */
    time?: number;
}
declare type FolmeEasingFunction = (options: FolmeEasingFunctionParams
/**  */
) => {
    /** Next tick value */
    value: number;
    /** Next tick velocity */
    velocity: number;
    /** Next tick whether finished */
    isFinished: boolean;
};
declare const MIN_VELOCITY = 0.001;
declare const MIN_VALUE = 0.001;

interface FolmeCoreState {
    name: string;
    value: number;
    target: number;
    velocity: number;
    time: number;
    startValue: number;
    startVelocity: number;
    easing: FolmeEasingFunction;
    isFinished: boolean;
    isPaused: boolean;
    unit: string;
}
interface FolmeCoreSetOptions {
    target?: string | number;
    current?: string | number;
    easing?: FolmeEasingFunction;
    velocity?: number;
    isPaused?: boolean;
}
declare function createCore(): {
    get: (propName: string) => FolmeCoreState;
    set: (propName: string, options: FolmeCoreSetOptions, trigger?: boolean) => void;
    del: (propName?: string) => void;
    start: () => void;
    stop: () => void;
    onUpdate: (fn: (state: FolmeCoreState[]) => void) => void;
    onStop: (fn: (state: FolmeCoreState[]) => void) => void;
};
declare type FolmeCore = ReturnType<typeof createCore>;

declare type Merge<A, B> = {
    [K in keyof A]: K extends keyof B ? B[K] : A[K];
} & B;
declare type FolmeTarget = string | HTMLElement | HTMLElement[] | NodeListOf<HTMLElement> | Object;
declare type FolmeOptionsFunction<T> = (index: number, elem: HTMLElement | Object, state: FolmeCoreState) => T;
declare type FolmeOptionsFunctionValue<T> = T extends Function ? never : T | FolmeOptionsFunction<T>;
declare type FolmeCallback = (target: any, states: FolmeCoreState[]) => void;
interface FolmeOptions<T extends string> {
    value?: FolmeOptionsFunctionValue<number | string>;
    delay?: FolmeOptionsFunctionValue<number>;
    velocity?: FolmeOptionsFunctionValue<number>;
    easing?: FolmeEasingFunction;
    onUpdate?: FolmeCallback;
    /** Called when target animation stop, regardless of whether there is a delayed task  */
    onStop?: FolmeCallback;
    /** Called when all target animation stop, including delayed tasks  */
    onFinish?: FolmeCallback;
    from?: Partial<Record<T, FolmeOptionsFunctionValue<number | string>>>;
}
interface FolmePropOptionsParsed<T extends string = never> extends FolmeOptions<T> {
    value: number | string;
    delay: number;
    velocity?: number;
}
declare type AssignFolmeOption<T extends string> = Record<T, number | string | FolmeOptions<T>>;
declare type FolmeProperty = Partial<AssignFolmeOption<"rotate" | "rotateX" | "rotateY" | "rotateZ" | "scale" | "scaleX" | "scaleY" | "scaleZ" | "skewX" | "skewY" | "translateX" | "translateY" | "translateZ" | keyof Properties>>;
/**
 * Create a transition bind to one or more elements.
 * @param target - Target elements to animate.
 * @param props - Target properties to animate.
 * @param options - Extra options.
 */
declare function to<T extends string>(target: FolmeTarget, props: Merge<AssignFolmeOption<T>, FolmeProperty>, options?: FolmeOptions<T>): Promise<{
    target: any;
    states: FolmeCoreState[];
}>;
/**
 * Set the properties of one or more elements immediately.
 * @see to
 *
 * @param target - Target elements to animate.
 * @param props - Target properties to animate.
 * @param options - Extra options.
 */
declare function set<T extends string>(target: FolmeTarget, props: Merge<AssignFolmeOption<T>, FolmeProperty>, options?: FolmeOptions<T>): void;
/**
 * Stop and cancel properties calculating of one or more elements immediately.
 *
 * @param target - Target elements to animate.
 * @param props - Target properties to animate. If not specified, will cancel all properties.
 *
 */
declare function cancel(target: FolmeTarget, props?: string[]): void;

declare function setStyle(elem: HTMLElement, props: FolmeProperty): void;

interface FolmeScrollModelCallbackParam {
    scroll: number;
    velocity: number;
    isDragging: boolean;
}
interface FolmeScrollModelOptions {
    min: number;
    max: number;
    coeff: number;
    dim: number;
    anchors: number[];
    spring: FolmeEasingFunction;
    frictionRate: number | ((velocity: number) => number);
    scrollToHandlerEnabled: boolean;
    scrollToTarget: number;
}
declare type FolmeScrollModelCallback = ((param: FolmeScrollModelCallbackParam) => void) | null;
declare function createScrollModel(opt: Partial<FolmeScrollModelOptions>): {
    drag: (deltaOffset: number, velocity: number) => void;
    drop: (velocity: number) => void;
    onChange: (fn: FolmeScrollModelCallback) => void;
    setting: (newOption: Partial<FolmeScrollModelOptions>) => void;
    scrollTo: (num: number, immediately?: boolean) => void;
    destroy: () => void;
};
declare type FolmeScrollModel = ReturnType<typeof createScrollModel>;

export { AssignFolmeOption, FolmeCallback, FolmeCore, FolmeCoreSetOptions, FolmeCoreState, FolmeDomEventQueue, FolmeEasingFunction, FolmeEasingFunctionParams, FolmeEventBus, FolmeOptions, FolmeOptionsFunction, FolmeOptionsFunctionValue, FolmePropOptionsParsed, FolmeProperty, FolmeScrollModel, FolmeTarget, FolmeTimer, FolmeTimerCallbackFunction, MIN_VALUE, MIN_VELOCITY, accDecNative, accNative, backIn, backInOut, backOut, bounceIn, bounceInOut, bounceNative, bounceOut, cancel, circIn, circInOut, circOut, createCore, createScrollModel, createTimer, cubicIn, cubicInOut, cubicOut, decNative, defineTweenFunction, deleteFromDelayQueue, deleteFromEventBus, elasticIn, elasticInOut, elasticOut, expoIn, expoInOut, expoOut, friction, getDelayEvents, getFrictionFinalValue, getFrictionRate, linear, measureDom, mutateDom, pushToDelayQueue, pushToEventBus, quadIn, quadInOut, quadOut, quartIn, quartInOut, quartOut, quintIn, quintInOut, quintOut, set, setStyle, sinIn, sinInOut, sinOut, spring, springNative, to };
