{"version":3,"file":"scroom.modern.js","sources":["../lib/utils.ts","../lib/setup.ts","../lib/debug.ts"],"sourcesContent":["export function genRange(start: number, stop: number, step = 1) {\n  if (step <= 0) {\n    return [start];\n  }\n  const range = Array(Math.ceil((stop - start) / step))\n    .fill(start)\n    .map((x, y) => x + y * step);\n  if (range[range.length - 1] !== stop) {\n    range.push(stop);\n  }\n  return range;\n}\n\nexport function climb(num: number, min: number, max: number) {\n  if (Math.abs(min - num) < Math.abs(max - num)) {\n    return min;\n  } else {\n    return max;\n  }\n}\n","import Emittery from 'emittery';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport { climb, genRange } from './utils';\n\n/** options for creating a scroom instance */\nexport interface CreateScroomOptions<T extends Element> {\n  /** target element */\n  target: T;\n  /** trigger distance from the top/left of the viewport. unit: %. range: 0 - 1. default: 0.5 */\n  offset?: number;\n  /** scrolling detection frequency threshold. unit: px. default: 4 */\n  threshold?: number;\n  /** scrolling detection direction. default: vertical */\n  direction?: 'vertical' | 'horizontal';\n}\n\n/** scroom instance events */\nexport interface ScroomEventMap<T> {\n  enter: {\n    target: T;\n  };\n  leave: {\n    target: T;\n  };\n  progress: {\n    target: T;\n    progress: number;\n  };\n  debug: {\n    target: T;\n    intersection: IntersectionObserverEntry;\n    offset: number;\n    progress: number;\n    direction: 'vertical' | 'horizontal';\n    action: 'enter' | 'progress' | 'leave' | null;\n  };\n}\n\n/** scroom instance */\nexport interface ScroomInstance<T extends Element> {\n  target: T;\n  /** intersection observer inside this instance */\n  observer: IntersectionObserver;\n  /** add event listener */\n  on: Emittery<ScroomEventMap<T>>['on'];\n  /** add event listener for once */\n  once: Emittery<ScroomEventMap<T>>['once'];\n  /** remove event listener */\n  off: Emittery<ScroomEventMap<T>>['off'];\n  /** destroy instance and remove all event listeners */\n  destroy: () => void;\n}\n\n/**\n * create a scroom instance\n * @param options - create options\n * @returns scroom instance\n */\nexport function createScroom<T extends Element>(options: CreateScroomOptions<T>): ScroomInstance<T> {\n  const { target, offset = 0.5, threshold = 4, direction = 'vertical' } = options;\n  const emitter = new Emittery<ScroomEventMap<T>>();\n\n  // observer for intersecting\n  let intersectionObserver: IntersectionObserver = createIntersectionObserver();\n\n  // observer for target size changing\n  let resizeObserver: ResizeObserver = createResizeObserver();\n\n  // listener for window resizing\n  window.addEventListener('resize', resizeHandler);\n\n  function createResizeObserver() {\n    const observer = new ResizeObserver(resizeHandler);\n    return observer;\n  }\n\n  function createIntersectionObserver() {\n    let rootMargin: string;\n    let thresholdStep: number;\n\n    // vertical\n    if (direction === 'vertical') {\n      const m1 = -offset * window.innerHeight;\n      const m2 = (offset - 1) * window.innerHeight + target.clientHeight;\n      // create a root bound box which same with target under trigger\n      rootMargin = `${m1}px 0px ${m2}px 0px`;\n      thresholdStep = threshold / target.clientHeight;\n    }\n    // horizontal\n    else {\n      const m1 = -offset * window.innerWidth;\n      const m2 = (offset - 1) * window.innerWidth + target.clientWidth;\n      rootMargin = `0px ${m2}px 0px ${m1}px`;\n      thresholdStep = threshold / target.clientWidth;\n    }\n\n    let isIntersectingLastTick = false;\n    let progressLastTick = -1;\n\n    let isFirstEnter = true;\n    setTimeout(() => {\n      isFirstEnter = false;\n    });\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        const { boundingClientRect: client, intersectionRect: rect, isIntersecting } = entry;\n        let isProgressing = false;\n        let progress = 0;\n\n        if (direction === 'vertical') {\n          isProgressing = client.top < rect.top && isIntersecting;\n          progress = 1 - rect.height / client.height;\n        } else if (direction === 'horizontal') {\n          isProgressing = client.left < rect.left && isIntersecting;\n          progress = 1 - rect.width / client.width;\n        }\n\n        const isEntering = !isIntersectingLastTick && isProgressing;\n        const isLeaving = isIntersectingLastTick && !isProgressing;\n        isIntersectingLastTick = isProgressing;\n\n        const emitProgress = (progress: number) => {\n          if (progressLastTick !== progress) {\n            emitter.emit('progress', {\n              target,\n              progress,\n            });\n          }\n          progressLastTick = progress;\n        };\n\n        if (isEntering) {\n          emitter.emit('enter', {\n            target,\n          });\n          if (!isFirstEnter) {\n            emitProgress(climb(progress, 0, 1));\n          }\n        }\n\n        if (isProgressing && progressLastTick !== progress) {\n          emitProgress(progress);\n        }\n\n        if (isLeaving) {\n          emitter.emit('leave', {\n            target,\n          });\n          emitProgress(climb(progress, 0, 1));\n        }\n\n        emitter.emit('debug', {\n          target,\n          progress,\n          offset,\n          intersection: entry,\n          direction,\n          action: isEntering ? 'enter' : isLeaving ? 'leave' : isProgressing ? 'progress' : null,\n        });\n      },\n      {\n        rootMargin,\n        threshold: genRange(0, 1, thresholdStep),\n      },\n    );\n    return observer;\n  }\n\n  function resizeHandler() {\n    intersectionObserver.disconnect();\n    intersectionObserver = createIntersectionObserver();\n    intersectionObserver.observe(target);\n  }\n\n  function destroy() {\n    intersectionObserver.disconnect();\n    resizeObserver.disconnect();\n    emitter.clearListeners();\n    window.removeEventListener('resize', resizeHandler);\n  }\n\n  // main\n  resizeObserver.observe(target);\n\n  return {\n    target,\n    observer: intersectionObserver,\n    destroy,\n    on: emitter.on.bind(emitter),\n    once: emitter.once.bind(emitter),\n    off: emitter.off.bind(emitter),\n  };\n}\n","import { ScroomEventMap, ScroomInstance } from './setup';\nimport randomColor from 'randomcolor';\n\nexport interface ScroomDebugController {\n  destroy: () => void;\n}\n\nexport function debug<T extends Element>(instance: ScroomInstance<T>, id?: string): ScroomDebugController {\n  const r = (randomColor({\n    luminosity: 'dark',\n    format: 'rgbArray',\n  }) as unknown) as number[];\n\n  const color = `rgb(${r[0]},${r[1]},${r[2]})`;\n  const alpha = `rgba(${r[0]},${r[1]},${r[2]},0.1)`;\n\n  const triggerLine = document.createElement('div');\n  const mask = document.createElement('div');\n\n  mask.style.cssText = `\n      position: fixed;\n      z-index: 100000;\n      background: ${alpha};\n      outline: 1px solid ${color};\n      pointer-events: none;\n    `;\n\n  document.body.appendChild(triggerLine);\n  document.body.appendChild(mask);\n\n  function intersectionHandler(event: ScroomEventMap<T>['debug']) {\n    const { offset, action, progress, direction, intersection } = event;\n\n    const display = action === 'enter' || action === 'progress' ? 'block' : 'none';\n\n    triggerLine.style.cssText = `\n      position: fixed;\n      z-index: 99999;\n      pointer-events: none;\n      display: ${display};\n      ${\n        direction === 'vertical'\n          ? `\n              left: 0;\n              width: 100%;\n              bottom: ${(1 - offset) * 100}%;\n              color: ${color};\n              border-bottom: 1px dashed ${color};\n              padding: 5px 20px;\n            `\n          : `\n              top: 0;\n              height: 100%;\n              right: ${(1 - offset) * 100}%;\n              color: ${color};\n              border-right: 1px dashed ${color};\n              padding: 20px 5px;\n            `\n      }\n    `;\n\n    mask.style.display = display;\n\n    const rect = intersection.boundingClientRect;\n    mask.style.top = rect.top + 'px';\n    mask.style.left = rect.left + 'px';\n    mask.style.width = rect.width + 'px';\n    mask.style.height = rect.height + 'px';\n\n    if (display) {\n      triggerLine.innerText = `${id ? `[${id}]` : ''}  ${(progress * 100).toFixed(3)}%`;\n    }\n  }\n\n  function positionHandler() {\n    const rect = instance.target.getBoundingClientRect();\n    mask.style.top = rect.top + 'px';\n    mask.style.left = rect.left + 'px';\n    mask.style.width = rect.width + 'px';\n    mask.style.height = rect.height + 'px';\n  }\n\n  instance.on('debug', intersectionHandler);\n  window.addEventListener('resize', positionHandler, false);\n  window.addEventListener('scroll', positionHandler, false);\n  positionHandler();\n\n  function destroy() {\n    instance.off('debug', intersectionHandler);\n    window.removeEventListener('resize', positionHandler, false);\n    window.removeEventListener('scroll', positionHandler, false);\n    triggerLine.remove();\n    mask.remove();\n  }\n\n  return {\n    destroy,\n  };\n}\n"],"names":["genRange","start","stop","step","range","Array","Math","ceil","fill","map","x","y","length","push","climb","num","min","max","abs","createScroom","options","target","offset","threshold","direction","emitter","Emittery","intersectionObserver","createIntersectionObserver","resizeObserver","ResizeObserver","resizeHandler","rootMargin","thresholdStep","window","innerHeight","clientHeight","m1","innerWidth","clientWidth","isIntersectingLastTick","progressLastTick","isFirstEnter","setTimeout","IntersectionObserver","entry","boundingClientRect","client","intersectionRect","rect","isIntersecting","isProgressing","progress","top","height","left","width","isEntering","isLeaving","emitProgress","emit","intersection","action","disconnect","observe","addEventListener","observer","destroy","clearListeners","removeEventListener","on","bind","once","off","debug","instance","id","r","randomColor","luminosity","format","color","alpha","triggerLine","document","createElement","mask","intersectionHandler","event","display","style","cssText","innerText","toFixed","positionHandler","getBoundingClientRect","body","appendChild","remove"],"mappings":"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"}